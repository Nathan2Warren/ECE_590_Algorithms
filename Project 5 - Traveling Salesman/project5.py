"""
Math 560
Project 5
Fall 2020

Partner 1: Nathan Warren (naw32)
Partner 2: Varun Prasad (vp60)
Date: November 20, 2020
"""

# Import math, itertools, and time.
from p5tests import *
import math
import itertools
import time
import random

# Import the Priority Queue.
from p5priorityQueue import *

################################################################################

"""
Prim's Algorithm: This function will use Prim's algorithm to create a minimum
spanning tree (MST). Effectively, this algorithm will use an arbitrary
vertex as the starting tree and will then find the lightest cost edge leading
out of the current tree. The unvisited vertices will be placed into a priority
queue. The process will repeat until an MST is created.


Inputs:
adjList: adjacency list for the map (list of Vertex objects)
adjMat: adjacency matrix for the map

Outputs: None
"""

def prim(adjList, adjMat):
    # Initialize all costs to inf and prev to none
    for vertex in adjList:
        vertex.cost = math.inf
        vertex.prev = None

    # Pick an arbitrary start vertex and set cost to 0
    start = adjList[0]
    start.cost = 0

    # Make the priority queue using cost for sorting
    Q = PriorityQueue(array = adjList)

    while not Q.isEmpty():
        # Get the next unvisited vertex and visit it
        v = Q.deleteMin()
        v.visited = True

        # For each edge out of v
        for neighbor in v.neigh:
            # If the edge leads out, update
            if not neighbor.visited:
                if neighbor.cost > adjMat[v.rank][neighbor.rank]:
                    neighbor.cost = adjMat[v.rank][neighbor.rank]
                    neighbor.prev = v

################################################################################


"""
Kruskal's Algorithm
Note: the edgeList is ALREADY SORTED!
Note: Use the isEqual method of the Vertex class when comparing vertices.

Kruskal's Algorithm: This function will use Kruskal's algorithm to create a
minimum spanning tree (MST). Effectively, this algorithm will start with an
empty tree and find the minimum cost edge. If that edge does not produce a
cycle, it will be added to the tree. The process will repeat until no more
edges can be added.


Inputs:
adjList: adjacency list for the map (list of Vertex objects)
edgeList: list of Edge objects for the map

Outputs:
X: the final MST

"""


def kruskal(adjList, edgeList):
    # Initialize all singleton sets for each vertex
    for vertex in adjList:
        makeset(vertex)
    # Initialize empty MST
    X = []

    # Loop through the edges in increasing order
    for e in edgeList:
        # If the min edge crosses a cut, add it to our MST
        u, v = e.vertices

        if find(u) != find(v):
            X.append(e)
            union(u, v)
    return X


################################################################################

"""
Disjoint Set Functions:
    makeset
    find
    union

These functions will operate directly on the input vertex objects.
"""

"""
makeset: this function will create a singleton set with root v.
"""


def makeset(v):
    v.pi = v
    v.height = 0


"""
find: this function will return the root of the set that contains v.
Note: we will use path compression here.

"""


def find(v):
    while v != v.pi:
        v = v.pi
    return v.pi


"""
union: this function will union the sets of vertices v and u.
"""


def union(u, v):
    # union by height
    # make the root of one point to the root of the other.
    # Find root of the tree for u
    ru = find(u)
    rv = find(v)

    # If the sets are already the same, return
    if ru == rv:
        return

    if ru.height > rv.height:
        rv.pi = ru

    elif ru.height < rv.height:
        ru.pi = rv

    else:
        # Same height, break tie
        ru.pi = rv

        # Tree got taller, increment rv.height
        rv.height += 1
    return

################################################################################


"""
TSP: This function will track the list of vertices generated by the MST to
solve the Travelling Salesman Problem using DFS. The function will check if
there are still unvisted vertices in the stack, and it will also check their
neighbors. Effectively, by using DFS and checking the visited status of the
vertices, we can take "shortcuts" through the MST to find the optimal path
and solve the Travelling Salesman Problem.

Inputs:
adjList: the adjacency list for the map (list of Vertex objects)
start: the starting vertex

Outputs:
tour: the path of vertices that corresponds to an optimal route for solving
the travelling salesman problem

"""
def tsp(adjList, start):
    # Initialize stack of vertices
    stack = []

    # Initialize tour of ranks
    tour = []

    # Append start to stack
    stack.append(start)

    # Set each vertex as unvisted
    for v in adjList:
        v.visited = False

    # Run loop while stack is not empty
    while len(stack) != 0:
        # Obtain current Vertex
        current = stack.pop()

        # Check if current vertex has been visited
        if current.visited == False:
            # If it has not proceed
            current.visited = True
            tour.append(current.rank)

            # Check neighbors, initializing previous and visited values
            for n in current.mstN:
                stack.append(n)

    # Add start vertex to complete cycle
    tour.append(start.rank)

    return tour
################################################################################


# Import the tests (since we have now defined prim and kruskal).

"""
Main function.
"""
if __name__ == "__main__":
    verb = False  # Set to true for more printed info.
    print('Testing Prim\n')
    print(testMaps(prim, verb))
    print('\nTesting Kruskal\n')
    print(testMaps(kruskal, verb))
